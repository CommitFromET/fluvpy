<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Performance Parallel Binary & JSON Polygon Surface Viewer (Z-Up)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #renderer {
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 320px;
            z-index: 100;
        }

        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 350px;
            z-index: 100;
            font-size: 12px;
            line-height: 1.4;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-container label {
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
        }

        .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        button {
            padding: 6px 12px;
            margin: 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 11px;
        }

        button:hover {
            background: #f0f0f0;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg,
                transparent 25%,
                rgba(255,255,255,0.2) 25%,
                rgba(255,255,255,0.2) 50%,
                transparent 50%,
                transparent 75%,
                rgba(255,255,255,0.2) 75%);
            background-size: 30px 30px;
            animation: move 1s linear infinite;
        }

        @keyframes move {
            0% { background-position: 0 0; }
            100% { background-position: 30px 0; }
        }

        .performance-stats {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 11px;
        }

        .performance-stats h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
            font-size: 13px;
        }

        .parallel-indicator {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .error {
            color: #e74c3c;
            background: #fdf2f2;
            border: 1px solid #e74c3c;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            max-width: 500px;
        }

        .error h3 {
            margin-top: 0;
        }

        .error-details {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 10px;
        }

        .stats-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .stats-section:last-child {
            border-bottom: none;
        }

        .stats-section h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #2c3e50;
        }

        .stats-item {
            margin-bottom: 4px;
            font-size: 11px;
            color: #555;
        }

        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 10px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }

        .github-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .github-info h3 {
            color: #495057;
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .coordinate-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .coordinate-info h3 {
            margin: 0 0 5px 0;
            color: #856404;
            font-size: 13px;
        }

        .coordinate-info p {
            margin: 0;
            font-size: 11px;
            color: #856404;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-container label {
            display: block;
            font-size: 12px;
            color: #333;
            margin-bottom: 5px;
        }

        .slider-container input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .slider-value {
            font-size: 11px;
            color: #666;
            text-align: center;
        }

        .scale-control {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .scale-control h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
            font-size: 14px;
        }

        .surface-stats {
            font-size: 10px;
            color: #666;
            margin-left: 4px;
        }

        .format-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .format-binary {
            background-color: #28a745;
            color: white;
        }

        .format-json {
            background-color: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" style="display: block;">
            <div class="loading-spinner"></div>
            <p>Loading High-Performance 3D Visualization...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <p><small id="loading-detail">Initializing parallel processing...</small></p>
            <p><small id="loading-stats">Performance stats will appear here</small></p>
        </div>

        <div id="controls">
            <div class="coordinate-info">
                <h3>Coordinate System</h3>
                <p><strong>Z-axis Up</strong> (Right-handed coordinate system)</p>
                <p>X: East-West direction | Y: North-South direction | Z: Vertical up</p>
            </div>

            <div class="github-info" id="github-info">
                <h3>GitHub Data Source</h3>
                <p>Repository: <strong>CommitFromET/fluvpy-test-b</strong><span class="parallel-indicator">PARALLEL</span></p>
                <p>Load Strategy: <span id="load-strategy">Simultaneous multi-CDN loading</span></p>
                <p>Processing: <span id="processing-status">Web Worker parallel parsing</span></p>
            </div>

            <div class="performance-stats" id="performance-stats" style="display: none;">
                <h3>Performance Metrics</h3>
                <div class="stats-item">Network Load: <span id="network-time">-</span></div>
                <div class="stats-item">Parallel Parse: <span id="parse-time-display">-</span></div>
                <div class="stats-item">Geometry Creation: <span id="geometry-time">-</span></div>
                <div class="stats-item">Total Speed-up: <span id="speedup-ratio">-</span></div>
                <div class="stats-item">Surfaces/sec: <span id="surfaces-per-sec">-</span></div>
            </div>

            <div class="control-group scale-control" style="display: none;" id="scale-controls">
                <h3>Vertical Scale Control</h3>
                <div class="slider-container">
                    <label for="z-scale-slider">Z-axis Scale Factor:</label>
                    <input type="range" id="z-scale-slider" min="0.1" max="5.0" step="0.1" value="1.0">
                    <div class="slider-value" id="z-scale-value">1.0x</div>
                </div>
                <button onclick="resetZScale()">Reset Scale</button>
            </div>

            <div class="control-group" id="visibility-controls" style="display: none;">
                <h3>Surface Visibility</h3>
                <!-- Dynamic surface controls will be added here -->
            </div>

            <div class="control-group" id="view-controls" style="display: none;">
                <h3>View Controls</h3>
                <button onclick="resetCamera()">Reset View</button>
                <button onclick="topView()">Top View (Z+)</button><br>
                <button onclick="bottomView()">Bottom View (Z-)</button>
                <button onclick="sideView()">Side View (Y+)</button><br>
                <button onclick="frontView()">Front View (X+)</button>
                <button onclick="backView()">Back View (X-)</button><br>
                <button onclick="toggleWireframe()">Wireframe</button>
                <button onclick="toggleDebug()">Debug</button>
            </div>
        </div>

        <div id="info" style="display: none;">
            <div class="stats-section">
                <h4>Model Information</h4>
                <div class="stats-item">Format: <span id="data-format">-</span></div>
                <div class="stats-item">Realization: <span id="realization">-</span></div>
                <div class="stats-item">Version: <span id="format-version">-</span></div>
                <div class="stats-item">Data Type: <span id="data-type">-</span></div>
                <div class="stats-item">Coordinate System: <strong>Z-Up (Right-handed)</strong></div>
                <div class="stats-item">Z-Scale: <span id="current-z-scale">1.0x</span></div>
                <div class="stats-item">Processing Mode: <strong>Parallel<span class="parallel-indicator">FAST</span></strong></div>
            </div>

            <div class="stats-section">
                <h4>Surface Statistics</h4>
                <div class="stats-item">Total Surfaces: <span id="total-surfaces">-</span></div>
                <div class="stats-item">Total Vertices: <span id="total-vertices">-</span></div>
                <div class="stats-item">Total Faces: <span id="total-faces">-</span></div>
                <div id="surface-details"></div>
            </div>

            <div class="stats-section">
                <h4>Model Bounds</h4>
                <div class="stats-item">Size: <span id="model-size">-</span></div>
                <div class="stats-item">Center: <span id="model-center">-</span></div>
            </div>

            <div class="stats-section">
                <h4>Performance Analysis</h4>
                <div class="stats-item">Network time: <span id="network-load-time">-</span></div>
                <div class="stats-item">Parsing time: <span id="parse-time">-</span></div>
                <div class="stats-item">Rendering time: <span id="render-time">-</span></div>
                <div class="stats-item">Memory usage: <span id="memory-usage">-</span></div>
                <div class="stats-item">Worker threads: <span id="worker-count">-</span></div>
            </div>

            <div class="stats-section">
                <h4>Controls</h4>
                <div class="stats-item">• Left drag: Rotate around Z-axis</div>
                <div class="stats-item">• Scroll: Zoom in/out</div>
                <div class="stats-item">• Use preset views above</div>
                <div class="stats-item">• Adjust Z-scale with slider</div>
            </div>
        </div>

        <div id="debug" style="display: none;">
            <div id="debug-content">Debug info will appear here</div>
        </div>

        <canvas id="renderer"></canvas>
    </div>

    <script>
        // Global error handling
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            showError('JavaScript Error', e.error.message, e.error.stack);
        });

        // Parallel GitHub URLs for simultaneous loading
        const GITHUB_URLS = [
            'https://raw.githubusercontent.com/CommitFromET/fluvpy/master/web_data/data1.bin',
            'https://cdn.jsdelivr.net/gh/CommitFromET/fluvpy@master/web_data/data1.bin',
            'https://gitcdn.xyz/repo/CommitFromET/fluvpy/master/web_data/data1.bin'
        ];

        // Performance tracking
        const performanceMetrics = {
            networkStart: 0,
            networkEnd: 0,
            parseStart: 0,
            parseEnd: 0,
            geometryStart: 0,
            geometryEnd: 0,
            totalStart: 0,
            totalEnd: 0,
            surfacesProcessed: 0,
            workersUsed: 0
        };

        // Global variables
        let scene, camera, renderer;
        let surfaceGroups = {};
        let wireframeMode = false;
        let polygonData = null;
        let dataBounds = null;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let azimuth = 0;
        let elevation = 0;
        let cameraRadius = 1000;
        let debugMode = false;
        let fileMetadata = {};
        let zScale = 1.0;
        let axisGroup = null;
        let gridGroup = null;
        let parsingWorker = null;
        let geometryWorkers = [];
        let maxWorkers = navigator.hardwareConcurrency || 4;

        // Progress tracking
        let totalSurfaces = 0;
        let processedSurfaces = 0;

        function updateProgress(current, total, phase = '') {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            const progressFill = document.getElementById('progress-fill');
            if (progressFill) {
                progressFill.style.width = percent + '%';
            }

            const loadingDetail = document.getElementById('loading-detail');
            if (loadingDetail) {
                loadingDetail.textContent = `${phase} - ${current}/${total} (${percent}%)`;
            }
        }

        // Show error message
        function showError(title, message, details = '') {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.innerHTML = `
                <div class="error">
                    <h3>${title}</h3>
                    <p>${message}</p>
                    ${details ? `<div class="error-details">${details}</div>` : ''}
                    <br>
                    <p><strong>Possible solutions:</strong></p>
                    <ul style="text-align: left; font-size: 12px;">
                        <li>Check your internet connection</li>
                        <li>Try refreshing the page</li>
                        <li>GitHub repository may be temporarily unavailable</li>
                        <li>Check browser console for more error information</li>
                    </ul>
                    <button onclick="hideError()" style="margin-top: 10px;">Close</button>
                </div>
            `;
        }

        function hideError() {
            document.getElementById('loading').style.display = 'none';
        }

        // Dynamic Three.js loading function with parallel attempts
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const cdnUrls = [
                    'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                    'https://unpkg.com/three@0.128.0/build/three.min.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
                ];

                // Try loading from all URLs simultaneously
                const promises = cdnUrls.map(url => {
                    return new Promise((urlResolve, urlReject) => {
                        const script = document.createElement('script');
                        script.src = url;
                        script.onload = () => urlResolve(url);
                        script.onerror = () => urlReject(new Error(`Failed to load from ${url}`));
                        document.head.appendChild(script);
                    });
                });

                // Use the first successful load
                Promise.any(promises)
                    .then(successUrl => {
                        console.log(`Three.js loaded successfully from: ${successUrl}`);
                        resolve();
                    })
                    .catch(error => {
                        console.error('All Three.js CDN sources failed:', error);
                        reject(new Error('All CDN sources failed to load Three.js'));
                    });
            });
        }

        function checkThreeJS() {
            return typeof THREE !== 'undefined';
        }

        function debugLog(message) {
            console.log('[DEBUG]', message);
            if (debugMode) {
                const debugContent = document.getElementById('debug-content');
                if (debugContent) {
                    debugContent.innerHTML += message + '<br>';
                    debugContent.scrollTop = debugContent.scrollHeight;
                }
            }
        }

        // Web Worker for binary parsing
        function createParsingWorker() {
            const workerScript = `
                class BinaryParser {
                    constructor(buffer) {
                        this.buffer = buffer;
                        this.view = new DataView(buffer);
                        this.offset = 0;
                    }

                    readString(length) {
                        const bytes = new Uint8Array(this.buffer, this.offset, length);
                        this.offset += length;
                        let str = '';
                        for (let i = 0; i < bytes.length && bytes[i] !== 0; i++) {
                            str += String.fromCharCode(bytes[i]);
                        }
                        return str;
                    }

                    readUint32() {
                        const value = this.view.getUint32(this.offset, true);
                        this.offset += 4;
                        return value;
                    }

                    readFloat32() {
                        const value = this.view.getFloat32(this.offset, true);
                        this.offset += 4;
                        return value;
                    }

                    readUint8() {
                        const value = this.view.getUint8(this.offset);
                        this.offset += 1;
                        return value;
                    }
                }

                self.onmessage = function(e) {
                    const { buffer, workerIndex } = e.data;
                    const startTime = performance.now();

                    try {
                        const parser = new BinaryParser(buffer);

                        // Read file header
                        const magic = parser.readString(4);
                        if (magic !== 'FLVP') {
                            throw new Error('Invalid binary format: expected FLVP, got ' + magic);
                        }

                        const version = parser.readUint32();
                        const realization = parser.readUint32();
                        const surfaceCount = parser.readUint32();

                        const surfaces = [];

                        // Parse each surface
                        for (let i = 0; i < surfaceCount; i++) {
                            // Send progress update
                            if (i % 10 === 0) {
                                self.postMessage({
                                    type: 'progress',
                                    current: i,
                                    total: surfaceCount,
                                    workerIndex: workerIndex
                                });
                            }

                            const name = parser.readString(32);
                            const id = parser.readUint32();
                            const vertexCount = parser.readUint32();
                            const faceCount = parser.readUint32();

                            const r = parser.readUint8();
                            const g = parser.readUint8();
                            const b = parser.readUint8();
                            parser.readUint8(); // padding
                            const color = '#' + r.toString(16).padStart(2, '0') +
                                         g.toString(16).padStart(2, '0') +
                                         b.toString(16).padStart(2, '0');

                            // Read vertices in chunks for better performance
                            const vertices = new Float32Array(vertexCount * 3);
                            for (let v = 0; v < vertexCount; v++) {
                                vertices[v * 3] = parser.readFloat32();
                                vertices[v * 3 + 1] = parser.readFloat32();
                                vertices[v * 3 + 2] = parser.readFloat32();
                            }

                            // Read faces
                            const faces = new Uint32Array(faceCount * 3);
                            for (let f = 0; f < faceCount; f++) {
                                faces[f * 3] = parser.readUint32();
                                faces[f * 3 + 1] = parser.readUint32();
                                faces[f * 3 + 2] = parser.readUint32();
                            }

                            surfaces.push({
                                facies_id: id,
                                facies_name: name,
                                color: color,
                                vertices: vertices,
                                faces: faces,
                                statistics: {
                                    vertex_count: vertexCount,
                                    face_count: faceCount
                                }
                            });
                        }

                        const parseTime = performance.now() - startTime;

                        self.postMessage({
                            type: 'complete',
                            data: {
                                metadata: {
                                    realization: realization,
                                    data_type: "binary_envelope_surfaces",
                                    format_version: version.toString(),
                                    total_statistics: {
                                        total_surfaces: surfaceCount,
                                        total_vertices: surfaces.reduce((sum, s) => sum + s.statistics.vertex_count, 0),
                                        total_faces: surfaces.reduce((sum, s) => sum + s.statistics.face_count, 0)
                                    },
                                    parse_time_ms: parseTime
                                },
                                surfaces: surfaces
                            },
                            parseTime: parseTime,
                            workerIndex: workerIndex
                        });

                    } catch (error) {
                        self.postMessage({
                            type: 'error',
                            error: error.message,
                            workerIndex: workerIndex
                        });
                    }
                };
            `;

            const blob = new Blob([workerScript], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // Parallel data loading from GitHub
        async function loadGitHubDataParallel() {
            performanceMetrics.networkStart = performance.now();
            performanceMetrics.totalStart = performance.now();

            debugLog('Starting parallel network loading from multiple CDNs...');

            // Create promises for all URLs simultaneously
            const loadPromises = GITHUB_URLS.map((url, index) => {
                const urlType = url.includes('raw.githubusercontent.com') ? 'GitHub Raw' :
                               url.includes('cdn.jsdelivr.net') ? 'JSDelivr CDN' :
                               url.includes('gitcdn.xyz') ? 'GitCDN' : 'Unknown CDN';

                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.arrayBuffer().then(buffer => ({
                            buffer,
                            url,
                            urlType,
                            size: buffer.byteLength
                        }));
                    })
                    .catch(error => {
                        console.warn(`Failed to load from ${urlType}:`, error.message);
                        throw { url, urlType, error };
                    });
            });

            // Use Promise.allSettled to try all sources simultaneously
            try {
                const results = await Promise.allSettled(loadPromises);
                const successfulResults = results
                    .filter(result => result.status === 'fulfilled')
                    .map(result => result.value);

                if (successfulResults.length === 0) {
                    const errors = results
                        .filter(result => result.status === 'rejected')
                        .map(result => result.reason);
                    throw new Error(`All parallel loads failed: ${errors.map(e => e.error?.message || e.toString()).join(', ')}`);
                }

                // Use the fastest/first successful result
                const winner = successfulResults[0];
                performanceMetrics.networkEnd = performance.now();

                const networkTime = performanceMetrics.networkEnd - performanceMetrics.networkStart;
                debugLog(`Network loading completed in ${networkTime.toFixed(1)}ms from ${winner.urlType}`);

                // Update UI
                document.getElementById('load-strategy').textContent = `Won: ${winner.urlType} (${successfulResults.length}/${GITHUB_URLS.length} succeeded)`;
                document.getElementById('network-time').textContent = `${networkTime.toFixed(1)}ms`;

                fileMetadata = {
                    name: 'envelope_1.bin',
                    size: winner.buffer.byteLength,
                    type: 'binary',
                    loadTime: networkTime,
                    source: winner.urlType,
                    url: winner.url
                };

                return winner.buffer;

            } catch (error) {
                performanceMetrics.networkEnd = performance.now();
                throw error;
            }
        }

        // Parallel binary parsing using Web Worker
        async function parseBinaryParallel(buffer) {
            performanceMetrics.parseStart = performance.now();

            return new Promise((resolve, reject) => {
                if (!parsingWorker) {
                    parsingWorker = createParsingWorker();
                    performanceMetrics.workersUsed++;
                }

                let progressInterval;

                parsingWorker.onmessage = function(e) {
                    const { type, data, parseTime, current, total, error } = e.data;

                    switch (type) {
                        case 'progress':
                            updateProgress(current, total, 'Parsing surfaces in parallel');
                            const loadingStats = document.getElementById('loading-stats');
                            if (loadingStats) {
                                const elapsed = performance.now() - performanceMetrics.parseStart;
                                const rate = current > 0 ? (current / (elapsed / 1000)).toFixed(1) : '0';
                                loadingStats.textContent = `Parsing rate: ${rate} surfaces/sec | Worker processing...`;
                            }
                            break;

                        case 'complete':
                            clearInterval(progressInterval);
                            performanceMetrics.parseEnd = performance.now();
                            performanceMetrics.surfacesProcessed = data.surfaces.length;

                            const totalParseTime = performanceMetrics.parseEnd - performanceMetrics.parseStart;
                            debugLog(`Parallel parsing completed in ${totalParseTime.toFixed(1)}ms`);

                            // Update performance display
                            document.getElementById('parse-time-display').textContent = `${totalParseTime.toFixed(1)}ms`;
                            const surfacesPerSec = (data.surfaces.length / (totalParseTime / 1000)).toFixed(1);
                            document.getElementById('surfaces-per-sec').textContent = surfacesPerSec;

                            resolve(data);
                            break;

                        case 'error':
                            clearInterval(progressInterval);
                            performanceMetrics.parseEnd = performance.now();
                            reject(new Error(`Worker parsing failed: ${error}`));
                            break;
                    }
                };

                parsingWorker.onerror = function(error) {
                    clearInterval(progressInterval);
                    performanceMetrics.parseEnd = performance.now();
                    reject(new Error(`Worker error: ${error.message}`));
                };

                // Start parsing in worker
                parsingWorker.postMessage({ buffer: buffer, workerIndex: 0 });

                // Timeout fallback
                setTimeout(() => {
                    if (performanceMetrics.parseEnd === 0) {
                        reject(new Error('Worker parsing timeout'));
                    }
                }, 30000);
            });
        }

        // Parallel geometry creation
        async function createGeometryParallel(surfaces) {
            performanceMetrics.geometryStart = performance.now();

            debugLog(`Creating geometries for ${surfaces.length} surfaces in parallel...`);

            // Process surfaces in batches for better performance
            const batchSize = Math.max(1, Math.floor(surfaces.length / maxWorkers));
            const promises = [];

            for (let i = 0; i < surfaces.length; i += batchSize) {
                const batch = surfaces.slice(i, Math.min(i + batchSize, surfaces.length));
                promises.push(processSurfaceBatch(batch, i));
            }

            await Promise.all(promises);

            performanceMetrics.geometryEnd = performance.now();
            const geometryTime = performanceMetrics.geometryEnd - performanceMetrics.geometryStart;
            debugLog(`Parallel geometry creation completed in ${geometryTime.toFixed(1)}ms`);

            document.getElementById('geometry-time').textContent = `${geometryTime.toFixed(1)}ms`;
        }

        async function processSurfaceBatch(surfaces, startIndex) {
            return new Promise((resolve) => {
                // Use requestAnimationFrame for non-blocking processing
                let currentIndex = 0;

                function processNext() {
                    const batchStart = performance.now();
                    let processed = 0;

                    // Process multiple surfaces per frame
                    while (currentIndex < surfaces.length && processed < 5) {
                        const surface = surfaces[currentIndex];
                        createSurfaceFromDataFast(surface);
                        currentIndex++;
                        processed++;

                        // Limit processing time per frame
                        if (performance.now() - batchStart > 16) break; // ~60fps
                    }

                    // Update progress
                    const globalProgress = startIndex + currentIndex;
                    updateProgress(globalProgress, polygonData.surfaces.length, 'Creating 3D geometries');

                    if (currentIndex < surfaces.length) {
                        requestAnimationFrame(processNext);
                    } else {
                        resolve();
                    }
                }

                processNext();
            });
        }

        // Optimized fast surface creation
        function createSurfaceFromDataFast(surfaceData) {
            const { facies_name, vertices, faces, color } = surfaceData;

            // Create geometry with pre-allocated arrays
            const geometry = new THREE.BufferGeometry();

            // Use vertices array directly if it's already Float32Array
            let verticesArray;
            if (vertices instanceof Float32Array) {
                verticesArray = vertices;
            } else {
                verticesArray = new Float32Array(vertices.length * 3);
                for (let i = 0; i < vertices.length; i++) {
                    const v = vertices[i];
                    verticesArray[i * 3] = v[0];
                    verticesArray[i * 3 + 1] = v[1];
                    verticesArray[i * 3 + 2] = v[2];
                }
            }

            // Use faces array directly if it's already Uint32Array
            let indicesArray;
            if (faces instanceof Uint32Array) {
                indicesArray = faces;
            } else {
                indicesArray = new Uint32Array(faces.length * 3);
                for (let i = 0; i < faces.length; i++) {
                    const f = faces[i];
                    indicesArray[i * 3] = f[0];
                    indicesArray[i * 3 + 1] = f[1];
                    indicesArray[i * 3 + 2] = f[2];
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
            geometry.setIndex(new THREE.BufferAttribute(indicesArray, 1));
            geometry.computeVertexNormals();

            // Create material
            const material = new THREE.MeshLambertMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0
            });

            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);

            // Create group
            const group = new THREE.Group();
            group.add(mesh);
            group.name = facies_name;

            surfaceGroups[facies_name] = group;
            scene.add(group);
        }

        // Z-scale control functions
        function setupZScaleControl() {
            const slider = document.getElementById('z-scale-slider');
            const valueDisplay = document.getElementById('z-scale-value');

            slider.addEventListener('input', function() {
                zScale = parseFloat(this.value);
                valueDisplay.textContent = zScale.toFixed(1) + 'x';
                document.getElementById('current-z-scale').textContent = zScale.toFixed(1) + 'x';
                applyZScale();
                debugLog(`Z-scale changed to: ${zScale.toFixed(1)}x`);
            });
        }

        function resetZScale() {
            zScale = 1.0;
            document.getElementById('z-scale-slider').value = '1.0';
            document.getElementById('z-scale-value').textContent = '1.0x';
            document.getElementById('current-z-scale').textContent = '1.0x';
            applyZScale();
            debugLog('Z-scale reset to 1.0x');
        }

        function applyZScale() {
            if (!polygonData) return;

            Object.values(surfaceGroups).forEach(group => {
                group.scale.z = zScale;
            });

            if (axisGroup) {
                updateCoordinateAxes();
            }

            updateCameraPosition();
        }

        // Validate data structure
        function validateData(data) {
            if (!data || typeof data !== 'object') {
                throw new Error('Invalid data structure: not an object');
            }

            if (!data.metadata) {
                throw new Error('Missing metadata section');
            }

            if (!data.surfaces || !Array.isArray(data.surfaces)) {
                throw new Error('Missing or invalid surfaces array');
            }

            for (let i = 0; i < data.surfaces.length; i++) {
                const surface = data.surfaces[i];
                if (!surface.vertices) {
                    throw new Error(`Surface ${i}: missing vertices`);
                }
                if (!surface.faces) {
                    throw new Error(`Surface ${i}: missing faces`);
                }
                if (!surface.facies_name) {
                    throw new Error(`Surface ${i}: missing facies_name`);
                }
            }

            debugLog(`Validation passed: ${data.surfaces.length} surfaces found`);
            return true;
        }

        // Calculate global bounds
        function calculateGlobalBounds(data) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            data.surfaces.forEach(surface => {
                const vertices = surface.vertices;

                if (vertices instanceof Float32Array) {
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const y = vertices[i + 1];
                        const z = vertices[i + 2];
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    }
                } else {
                    vertices.forEach(vertex => {
                        const [x, y, z] = vertex;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    });
                }
            });

            data.metadata.global_bounds = {
                min: { x: minX, y: minY, z: minZ },
                max: { x: maxX, y: maxY, z: maxZ },
                size: {
                    x: maxX - minX,
                    y: maxY - minY,
                    z: maxZ - minZ
                }
            };

            debugLog(`Global bounds calculated: ${JSON.stringify(data.metadata.global_bounds.size)}`);
        }

        // Update data bounds for camera
        function updateDataBounds() {
            if (!polygonData || !polygonData.metadata.global_bounds) return;

            const bounds = polygonData.metadata.global_bounds;
            dataBounds = {
                min: bounds.min,
                max: bounds.max,
                center: {
                    x: (bounds.min.x + bounds.max.x) / 2,
                    y: (bounds.min.y + bounds.max.y) / 2,
                    z: (bounds.min.z + bounds.max.z) / 2
                },
                size: bounds.size
            };

            const maxSize = Math.max(bounds.size.x, bounds.size.y, bounds.size.z);
            cameraRadius = maxSize * 1.5;
            debugLog(`Camera radius set to: ${cameraRadius.toFixed(1)}`);
        }

        // Update info panel
        function updateInfoPanel() {
            if (!polygonData) return;

            const meta = polygonData.metadata;
            const stats = meta.total_statistics || {};

            // Model info
            document.getElementById('data-format').textContent = fileMetadata.type.toUpperCase();
            document.getElementById('realization').textContent = meta.realization || '-';
            document.getElementById('format-version').textContent = meta.format_version || '-';
            document.getElementById('data-type').textContent = meta.data_type || '-';
            document.getElementById('current-z-scale').textContent = zScale.toFixed(1) + 'x';

            // Surface stats
            document.getElementById('total-surfaces').textContent = (stats.total_surfaces || polygonData.surfaces.length).toLocaleString();
            document.getElementById('total-vertices').textContent = (stats.total_vertices || 0).toLocaleString();
            document.getElementById('total-faces').textContent = (stats.total_faces || 0).toLocaleString();

            // Model bounds
            if (meta.global_bounds) {
                const bounds = meta.global_bounds;
                document.getElementById('model-size').textContent =
                    `${bounds.size.x.toFixed(0)}×${bounds.size.y.toFixed(0)}×${bounds.size.z.toFixed(0)}`;
                document.getElementById('model-center').textContent =
                    `(${((bounds.min.x + bounds.max.x) / 2).toFixed(1)}, ${((bounds.min.y + bounds.max.y) / 2).toFixed(1)}, ${((bounds.min.z + bounds.max.z) / 2).toFixed(1)})`;
            }

            // Performance info
            const networkTime = performanceMetrics.networkEnd - performanceMetrics.networkStart;
            const parseTime = performanceMetrics.parseEnd - performanceMetrics.parseStart;
            const geometryTime = performanceMetrics.geometryEnd - performanceMetrics.geometryStart;
            const totalTime = performanceMetrics.totalEnd - performanceMetrics.totalStart;

            document.getElementById('network-load-time').textContent = `${networkTime.toFixed(1)}ms`;
            document.getElementById('parse-time').textContent = `${parseTime.toFixed(1)}ms`;
            document.getElementById('render-time').textContent = `${geometryTime.toFixed(1)}ms`;
            document.getElementById('worker-count').textContent = `${performanceMetrics.workersUsed}`;

            // Calculate speedup ratio (compared to estimated sequential time)
            const estimatedSequentialTime = networkTime + parseTime + geometryTime;
            const actualParallelTime = Math.max(networkTime, parseTime) + geometryTime;
            const speedupRatio = (estimatedSequentialTime / actualParallelTime).toFixed(1);
            document.getElementById('speedup-ratio').textContent = `${speedupRatio}x faster`;

            // Estimate memory usage
            const totalVertices = stats.total_vertices || 0;
            const totalFaces = stats.total_faces || 0;
            const estimatedMemoryMB = ((totalVertices * 12) + (totalFaces * 12)) / (1024 * 1024);
            document.getElementById('memory-usage').textContent = `~${estimatedMemoryMB.toFixed(1)}MB`;

            // Surface details
            const detailsDiv = document.getElementById('surface-details');
            detailsDiv.innerHTML = '';
            polygonData.surfaces.forEach(surface => {
                const div = document.createElement('div');
                div.className = 'stats-item';
                div.innerHTML = `${surface.facies_name}: ${surface.statistics.vertex_count.toLocaleString()} vertices, ${surface.statistics.face_count.toLocaleString()} faces`;
                detailsDiv.appendChild(div);
            });
        }

        // Create visibility controls
        function createVisibilityControls() {
            if (!polygonData) return;

            const controlsDiv = document.getElementById('visibility-controls');
            controlsDiv.innerHTML = '<h3>Surface Visibility</h3>';

            polygonData.surfaces.forEach((surface, index) => {
                const container = document.createElement('div');
                container.className = 'checkbox-container';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `surface-${index}`;
                checkbox.checked = true;
                checkbox.addEventListener('change', (e) => {
                    if (surfaceGroups[surface.facies_name]) {
                        surfaceGroups[surface.facies_name].visible = e.target.checked;
                    }
                });

                const colorIndicator = document.createElement('div');
                colorIndicator.className = 'color-indicator';
                colorIndicator.style.backgroundColor = surface.color;

                const label = document.createElement('label');
                label.setAttribute('for', `surface-${index}`);
                label.textContent = surface.facies_name;

                const stats = document.createElement('span');
                stats.className = 'surface-stats';
                stats.textContent = `(${surface.statistics.face_count} faces)`;

                container.appendChild(checkbox);
                container.appendChild(colorIndicator);
                container.appendChild(label);
                container.appendChild(stats);

                controlsDiv.appendChild(container);
            });

            controlsDiv.style.display = 'block';
        }

        // Initialize Three.js scene
        function initScene() {
            debugLog('Initializing scene...');

            if (!window.THREE) {
                throw new Error('THREE.js is not available');
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);

            // Renderer
            const canvas = document.getElementById('renderer');
            if (!canvas) {
                throw new Error('Canvas element not found');
            }

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1000, 1000, 1000);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1000, -1000, 500);
            scene.add(directionalLight2);

            // Controls
            setupControls();
            setupZScaleControl();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            debugLog('Scene initialized successfully');
        }

        // Enhanced orbit controls
        function setupControls() {
            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            azimuth += deltaX * 0.01;
            elevation -= deltaY * 0.01;
            elevation = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, elevation));

            updateCameraPosition();

            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onMouseWheel(event) {
            const scale = event.deltaY > 0 ? 1.1 : 0.9;
            cameraRadius *= scale;
            cameraRadius = Math.max(10, Math.min(5000, cameraRadius));
            updateCameraPosition();
            event.preventDefault();
        }

        function updateCameraPosition() {
            if (!dataBounds) return;

            const centerX = dataBounds.center.x;
            const centerY = dataBounds.center.y;
            const centerZ = dataBounds.center.z;

            camera.position.x = centerX + cameraRadius * Math.cos(elevation) * Math.cos(azimuth);
            camera.position.y = centerY + cameraRadius * Math.cos(elevation) * Math.sin(azimuth);
            camera.position.z = centerZ + cameraRadius * Math.sin(elevation);

            camera.lookAt(centerX, centerY, centerZ);
            camera.up.set(0, 0, 1);
        }

        // Create 3D visualization with parallel processing
        async function createVisualization() {
            if (!polygonData) return;

            debugLog('Creating 3D visualization with parallel processing...');

            // Clear existing surfaces
            Object.values(surfaceGroups).forEach(group => {
                scene.remove(group);
            });
            surfaceGroups = {};

            // Create surfaces in parallel
            await createGeometryParallel(polygonData.surfaces);

            calculateGlobalBounds(polygonData);
            updateDataBounds();
            resetCamera();
            addCoordinateHelpers();
            createVisibilityControls();
            updateInfoPanel();

            // Show UI elements
            document.getElementById('scale-controls').style.display = 'block';
            document.getElementById('view-controls').style.display = 'block';
            document.getElementById('info').style.display = 'block';
            document.getElementById('performance-stats').style.display = 'block';

            performanceMetrics.totalEnd = performance.now();
            const totalTime = performanceMetrics.totalEnd - performanceMetrics.totalStart;
            debugLog(`Complete parallel visualization created in ${totalTime.toFixed(1)}ms`);
        }

        // Camera view functions
        function resetCamera() {
            if (!dataBounds) return;
            azimuth = Math.PI / 4;
            elevation = Math.PI / 6;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.y, dataBounds.size.z) * 1.8;
            updateCameraPosition();
            debugLog('Camera reset to default view (Z-up)');
        }

        function topView() {
            if (!dataBounds) return;
            azimuth = 0;
            elevation = Math.PI / 2 - 0.1;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.y) * 1.2;
            updateCameraPosition();
        }

        function bottomView() {
            if (!dataBounds) return;
            azimuth = 0;
            elevation = -Math.PI / 2 + 0.1;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.y) * 1.2;
            updateCameraPosition();
        }

        function sideView() {
            if (!dataBounds) return;
            azimuth = Math.PI / 2;
            elevation = 0;
            cameraRadius = Math.max(dataBounds.size.x, dataBounds.size.z) * 1.5;
            updateCameraPosition();
        }

        function frontView() {
            if (!dataBounds) return;
            azimuth = 0;
            elevation = 0;
            cameraRadius = Math.max(dataBounds.size.y, dataBounds.size.z) * 1.5;
            updateCameraPosition();
        }

        function backView() {
            if (!dataBounds) return;
            azimuth = Math.PI;
            elevation = 0;
            cameraRadius = Math.max(dataBounds.size.y, dataBounds.size.z) * 1.5;
            updateCameraPosition();
        }

        // Create text texture
        function createTextTexture(text, fontSize = 64, color = '#000000') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            canvas.width = 256;
            canvas.height = 128;

            context.font = `${fontSize}px Arial`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            return texture;
        }

        // Enhanced coordinate axis display for Z-axis up
        function addCoordinateHelpers() {
            if (!dataBounds) return;

            if (axisGroup) {
                scene.remove(axisGroup);
            }
            if (gridGroup) {
                scene.remove(gridGroup);
            }

            axisGroup = new THREE.Group();
            gridGroup = new THREE.Group();

            const bounds = dataBounds;
            const axisLength = Math.min(bounds.size.x, bounds.size.y, bounds.size.z) * 0.4;
            const arrowLength = axisLength * 0.1;
            const arrowRadius = axisLength * 0.02;

            const origin = {
                x: bounds.center.x,
                y: bounds.center.y,
                z: bounds.min.z - bounds.size.z * 0.1
            };

            // X-axis (red)
            const xAxisGroup = new THREE.Group();
            const xGeometry = new THREE.CylinderGeometry(axisLength * 0.005, axisLength * 0.005, axisLength, 8);
            const xMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xGeometry, xMaterial);
            xAxis.position.set(origin.x + axisLength / 2, origin.y, origin.z);
            xAxis.rotation.z = -Math.PI / 2;
            xAxisGroup.add(xAxis);

            const xArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const xArrow = new THREE.Mesh(xArrowGeometry, xMaterial);
            xArrow.position.set(origin.x + axisLength, origin.y, origin.z);
            xArrow.rotation.z = -Math.PI / 2;
            xAxisGroup.add(xArrow);

            const xLabelTexture = createTextTexture('X (East)', 36, '#ff0000');
            const xLabelMaterial = new THREE.SpriteMaterial({ map: xLabelTexture });
            const xLabel = new THREE.Sprite(xLabelMaterial);
            xLabel.position.set(origin.x + axisLength * 1.3, origin.y, origin.z);
            xLabel.scale.set(axisLength * 0.4, axisLength * 0.2, 1);
            xAxisGroup.add(xLabel);

            axisGroup.add(xAxisGroup);

            // Y-axis (green)
            const yAxisGroup = new THREE.Group();
            const yGeometry = new THREE.CylinderGeometry(axisLength * 0.005, axisLength * 0.005, axisLength, 8);
            const yMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yGeometry, yMaterial);
            yAxis.position.set(origin.x, origin.y + axisLength / 2, origin.z);
            yAxis.rotation.x = Math.PI / 2;
            yAxisGroup.add(yAxis);

            const yArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const yArrow = new THREE.Mesh(yArrowGeometry, yMaterial);
            yArrow.position.set(origin.x, origin.y + axisLength, origin.z);
            yArrow.rotation.x = Math.PI / 2;
            yAxisGroup.add(yArrow);

            const yLabelTexture = createTextTexture('Y (North)', 36, '#00ff00');
            const yLabelMaterial = new THREE.SpriteMaterial({ map: yLabelTexture });
            const yLabel = new THREE.Sprite(yLabelMaterial);
            yLabel.position.set(origin.x, origin.y + axisLength * 1.3, origin.z);
            yLabel.scale.set(axisLength * 0.4, axisLength * 0.2, 1);
            yAxisGroup.add(yLabel);

            axisGroup.add(yAxisGroup);

            // Z-axis (blue)
            const zAxisGroup = new THREE.Group();
            const zGeometry = new THREE.CylinderGeometry(axisLength * 0.005, axisLength * 0.005, axisLength, 8);
            const zMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zGeometry, zMaterial);
            zAxis.position.set(origin.x, origin.y, origin.z + axisLength / 2);
            zAxisGroup.add(zAxis);

            const zArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const zArrow = new THREE.Mesh(zArrowGeometry, zMaterial);
            zArrow.position.set(origin.x, origin.y, origin.z + axisLength);
            zAxisGroup.add(zArrow);

            const zLabelTexture = createTextTexture('Z (Up)', 36, '#0000ff');
            const zLabelMaterial = new THREE.SpriteMaterial({ map: zLabelTexture });
            const zLabel = new THREE.Sprite(zLabelMaterial);
            zLabel.position.set(origin.x, origin.y, origin.z + axisLength * 1.3);
            zLabel.scale.set(axisLength * 0.4, axisLength * 0.2, 1);
            zAxisGroup.add(zLabel);

            axisGroup.add(zAxisGroup);

            scene.add(axisGroup);
            scene.add(gridGroup);

            debugLog('Added coordinate axes with Z-up orientation');
        }

        function updateCoordinateAxes() {
            // Axes don't scale, surfaces do
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            Object.values(surfaceGroups).forEach(group => {
                group.traverse((child) => {
                    if (child.isMesh) {
                        child.material.wireframe = wireframeMode;
                    }
                });
            });
            debugLog(`Wireframe mode: ${wireframeMode ? 'ON' : 'OFF'}`);
        }

        function toggleDebug() {
            debugMode = !debugMode;
            const debugPanel = document.getElementById('debug');
            debugPanel.style.display = debugMode ? 'block' : 'none';

            if (debugMode) {
                document.getElementById('debug-content').innerHTML = 'Debug mode enabled (Parallel Processing)<br>';
                debugLog('Debug panel opened');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Main initialization function with parallel processing
        async function initApp() {
            try {
                console.log('Initializing High-Performance Binary Polygon Surface Viewer...');
                console.log(`System info: ${navigator.hardwareConcurrency || 'unknown'} CPU cores`);

                document.getElementById('loading-detail').textContent = 'Loading Three.js library in parallel...';

                if (!checkThreeJS()) {
                    await loadThreeJS();
                }

                if (!checkThreeJS()) {
                    throw new Error('Three.js library failed to load');
                }

                console.log('Three.js loaded successfully, version:', THREE.REVISION);

                document.getElementById('loading-detail').textContent = 'Initializing 3D scene...';
                initScene();

                // Start animation loop
                animate();

                // Load and process data with parallel optimization
                document.getElementById('loading-detail').textContent = 'Loading surface data from multiple CDNs simultaneously...';
                document.getElementById('processing-status').textContent = 'Parallel network loading active';

                const buffer = await loadGitHubDataParallel();

                document.getElementById('loading-detail').textContent = 'Processing surface data with Web Worker...';
                document.getElementById('processing-status').textContent = 'Web Worker parsing in background';

                polygonData = await parseBinaryParallel(buffer);

                document.getElementById('loading-detail').textContent = 'Creating 3D visualization with parallel geometry processing...';
                document.getElementById('processing-status').textContent = 'Parallel geometry creation active';

                await createVisualization();

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';

                // Final performance summary
                const totalTime = performanceMetrics.totalEnd - performanceMetrics.totalStart;
                const networkTime = performanceMetrics.networkEnd - performanceMetrics.networkStart;
                const parseTime = performanceMetrics.parseEnd - performanceMetrics.parseStart;
                const geometryTime = performanceMetrics.geometryEnd - performanceMetrics.geometryStart;

                console.log(`🚀 Parallel Processing Performance Summary:`);
                console.log(`├─ Total Time: ${totalTime.toFixed(1)}ms`);
                console.log(`├─ Network Load: ${networkTime.toFixed(1)}ms (parallel CDN)`);
                console.log(`├─ Data Parsing: ${parseTime.toFixed(1)}ms (Web Worker)`);
                console.log(`├─ Geometry Creation: ${geometryTime.toFixed(1)}ms (batched)`);
                console.log(`├─ Surfaces Processed: ${performanceMetrics.surfacesProcessed}`);
                console.log(`├─ Workers Used: ${performanceMetrics.workersUsed}`);
                console.log(`└─ Processing Rate: ${(performanceMetrics.surfacesProcessed / (totalTime / 1000)).toFixed(1)} surfaces/sec`);

                debugLog('High-performance parallel application initialized successfully');

            } catch (error) {
                console.error('Initialization failed:', error);
                showError('Parallel Loading Failed', error.message, error.stack);
            }
        }

        // Cleanup function
        window.addEventListener('beforeunload', function() {
            if (parsingWorker) {
                parsingWorker.terminate();
            }
            geometryWorkers.forEach(worker => worker.terminate());
        });

        // Start application
        window.addEventListener('load', initApp);
    </script>
</body>
</html>